#pragma once

#include <sys/stat.h>
#include <limits.h>
#include <errno.h>
#include <stdbool.h>
#include <stdio.h>
#include <unistd.h>

#include <uthash.h>

#include "definitions.h"

/*
 * Hash table entry to hold generated services.
 */
struct h_generated_service {
    UT_hash_handle hh;
    char *service_text;
    int service_text_len;
    time_t modification_time;
    char original_path[];
};

/*
 * An init-daemon-independant description of the service.
 */
struct service_desc {
    /*
     * A command to start the service.
     */
    char start[PATH_MAX];
    size_t start_len;

    /*
     * An optional command to stop the service.
     */
    char stop[PATH_MAX];
    size_t stop_len;

    /*
     * An optional command to run after the service has stopped.
     */
    char after_stop[PATH_MAX];
    size_t after_stop_len;

    /*
     * An optional path to the file which contains configuration / environment variables.
     */
    char conf[PATH_MAX];
    size_t conf_len;

    /*
     * An optional command to run as healthcheck.
     */
    char check[PATH_MAX];
    size_t check_len;
};

/*
 * Type of init daemon.
 */
enum service_type {
    SERVICE_TYPE_SYSTEMD,
    SERVICE_TYPE_RUNIT
};

/*
 * Init daemon type of the init stratum. Services from other strata
 * will be translated to this type.
 */
static enum service_type init_stratum_service_type;

/*
 * The hash table that holds generated services.
 */
static struct h_generated_service *generated_services = NULL;

static inline struct stratum *deref(struct back_entry *back);
static inline int inject_ini(struct cfg_entry *cfg, const char *ipath, size_t ipath_len, char *buf, size_t size, off_t offset);

static inline int generate_systemd_service(struct service_desc *desc, struct h_generated_service *generated_service) {
    generated_service->service_text_len = asprintf(
        &generated_service->service_text,
        "[Unit]\nDescription=This service was generated by bedrock from %s\n\n"
        "[Service]\nExecStart=%s\n",
        generated_service->original_path,
        desc->start
    );
    if (generated_service->service_text_len < 0)
        return generated_service->service_text_len;

    if (desc->after_stop_len > 0) {
        generated_service->service_text_len = asprintf(
            &generated_service->service_text,
            "%sExecStopPost=%s\n",
            generated_service->service_text,
            desc->after_stop
        );
        if (generated_service->service_text_len < 0)
            return generated_service->service_text_len;
    }
    if (desc->conf_len) {
        generated_service->service_text_len = asprintf(
            &generated_service->service_text,
            "%sEnvironmentFile=%s\n",
            generated_service->service_text,
            desc->conf
        );
        if (generated_service->service_text_len < 0)
            return generated_service->service_text_len;
    }

    // systemd doesn't know how to do healthchecks with arbitary scripts

    return 0;
}

static inline int generate_service_for(struct back_entry *back, char *bpath, enum service_type service_type, struct h_generated_service **generated_service) {
        char *service_stratum = deref(back)->name;

        char full_service_path[PATH_MAX] = STRATA_ROOT;
        strncat(full_service_path, service_stratum, PATH_MAX);
        strncat(full_service_path, bpath, PATH_MAX);

        struct stat original_service_stat;
        if (stat(full_service_path, &original_service_stat) != 0) {
            return -errno;
        }

        HASH_FIND_STR(generated_services, full_service_path, *generated_service);

        bool need_to_create = *generated_service == NULL;

        // If the modification date on the original service doesn't match the recorded one,
        // the service should be regenerated
        if (!need_to_create && (*generated_service)->modification_time != original_service_stat.st_mtime) {
            // Remove the service from the table, free the service's text, and free the service itself
            HASH_DEL(generated_services, *generated_service);
            free((*generated_service)->service_text);
            free(*generated_service);

            // Mark that a new service has to be generated
            need_to_create = true;
        }

        if (need_to_create) {
            struct service_desc service_desc = { .start_len = 0, .stop_len = 0, .conf_len = 0 };

            switch (service_type) {
            case SERVICE_TYPE_RUNIT:
                service_desc.start_len =
                    snprintf(service_desc.start, PATH_MAX, "/bedrock/bin/strat -r %s %s/run", service_stratum, full_service_path);

                // If there's a finish file, record to execute it after the service has stopped
                char after_stop_file_path[PATH_MAX];
                strncpy(after_stop_file_path, full_service_path, PATH_MAX);
                strcat(after_stop_file_path, "/finish");
                if (access(after_stop_file_path, F_OK) == 0) {
                    service_desc.after_stop_len = snprintf(
                        service_desc.after_stop, PATH_MAX, "/bedrock/bin/strat -r %s %s",
                        service_stratum, after_stop_file_path
                    );
                }

                char conf_file_path[PATH_MAX];
                strncpy(conf_file_path, full_service_path, PATH_MAX);
                strcat(conf_file_path, "/conf");
                if (access(conf_file_path, F_OK) == 0) {
                    service_desc.conf_len = strlen(conf_file_path);
                    strncpy(service_desc.conf, conf_file_path, service_desc.conf_len);
                }

                char check_file_path[PATH_MAX];
                strncpy(check_file_path, full_service_path, PATH_MAX);
                strcat(check_file_path, "/check");
                if (access(check_file_path, F_OK) == 0) {
                    service_desc.check_len = snprintf(
                        service_desc.check, PATH_MAX, "/bedrock/bin/strat -r %s %s",
                        service_stratum, check_file_path
                    );
                }

                break;
            }

            // Allocate space for a generated service + service path data
            *generated_service = malloc(sizeof(struct h_generated_service) + strlen(full_service_path) + 1);
            if (*generated_service == NULL)
                return -ENOMEM;

            strcpy((*generated_service)->original_path, full_service_path);

            switch (init_stratum_service_type) {
                case SERVICE_TYPE_SYSTEMD:
                    ;
                    int rv = generate_systemd_service(&service_desc, *generated_service);
                    if (rv < 0)
                        return rv;

                    break;
            }

            (*generated_service)->modification_time = original_service_stat.st_mtime;
            HASH_ADD_STR(generated_services, original_path, *generated_service);
        }
}

static inline int read_service(struct cfg_entry *cfg, const char *const ipath, size_t ipath_len,
                               char *buf, size_t size, off_t offset, struct back_entry *back, char *bpath,
                               enum service_type service_type) {
    if (init_stratum_service_type == service_type) {
        switch (service_type) {
        case SERVICE_TYPE_SYSTEMD:
            return inject_ini(cfg, ipath, ipath_len, buf, size, offset);
            break;
        }
    } else {
        struct h_generated_service *generated_service = NULL;
        generate_service_for(back, bpath, service_type, &generated_service);

        strncpy(buf, generated_service->service_text, generated_service->service_text_len);

        return generated_service->service_text_len;
    }
}
