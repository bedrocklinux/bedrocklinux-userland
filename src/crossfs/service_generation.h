#pragma once

#include <sys/stat.h>
#include <limits.h>
#include <errno.h>
#include <stdbool.h>
#include <stdio.h>
#include <unistd.h>
#include <libgen.h>

#include <uthash.h>

#include "definitions.h"

/*
 * A generated service.
 */
struct generated_service {
    char *service_text;
    int service_text_len;
    char original_path[];
};

/*
 * An init-daemon-independant description of the service.
 */
struct service_desc {
    /*
     * A command to start the service.
     */
    char start[PATH_MAX];
    size_t start_len;

    /*
     * An optional command to stop the service.
     */
    char stop[PATH_MAX];
    size_t stop_len;

    /*
     * An optional command to run after the service has stopped.
     */
    char after_stop[PATH_MAX];
    size_t after_stop_len;

    /*
     * An optional path to the file which contains configuration / environment variables.
     */
    char conf[PATH_MAX];
    size_t conf_len;

    /*
     * An optional command to run as healthcheck.
     */
    char check[PATH_MAX];
    size_t check_len;

    char pidfile[PATH_MAX];
    size_t pidfile_len;
};

/*
 * Type of init daemon.
 */
enum service_type {
    SERVICE_TYPE_SYSTEMD,
    SERVICE_TYPE_RUNIT,
    SERVICE_TYPE_OPENRC
};

/*
 * Init daemon type of the init stratum. Services from other strata
 * will be translated to this type.
 */
static enum service_type init_stratum_service_type;

static inline struct stratum *deref(struct back_entry *back);
static inline int inject_ini(struct cfg_entry *cfg, const char *ipath, size_t ipath_len, char *buf, size_t size, off_t offset);

static inline int generate_systemd_service(struct service_desc *desc, struct generated_service *generated_service) {
    generated_service->service_text_len = asprintf(
        &generated_service->service_text,
        "[Unit]\nDescription=Service generated by bedrock from %s\n\n"
        "[Service]\nExecStart=%s\n",
        generated_service->original_path,
        desc->start
    );
    if (generated_service->service_text_len < 0)
        return generated_service->service_text_len;

    if (desc->stop_len > 0) {
        generated_service->service_text_len = asprintf(
            &generated_service->service_text,
            "%sExecStop=%s\n",
            generated_service->service_text,
            desc->stop
        );
        if (generated_service->service_text_len < 0)
            return generated_service->service_text_len;
    }

    if (desc->after_stop_len > 0) {
        generated_service->service_text_len = asprintf(
            &generated_service->service_text,
            "%sExecStopPost=%s\n",
            generated_service->service_text,
            desc->after_stop
        );
        if (generated_service->service_text_len < 0)
            return generated_service->service_text_len;
    }
    if (desc->conf_len) {
        generated_service->service_text_len = asprintf(
            &generated_service->service_text,
            "%sEnvironmentFile=%s\n",
            generated_service->service_text,
            desc->conf
        );
        if (generated_service->service_text_len < 0)
            return generated_service->service_text_len;
    }

    if (desc->pidfile_len > 0) {
        generated_service->service_text_len = asprintf(
            &generated_service->service_text,
            "%sPIDFile=%s\n",
            generated_service->service_text,
            desc->pidfile
        );
        if (generated_service->service_text_len < 0)
            return generated_service->service_text_len;
    }

    // systemd doesn't know how to do healthchecks with arbitary scripts

    return 0;
}

static inline int generate_service_for(struct back_entry *back, char *bpath, enum service_type service_type, struct generated_service **generated_service) {
        char *service_stratum = deref(back)->name;

        char full_service_path[PATH_MAX] = STRATA_ROOT;
        strncat(full_service_path, service_stratum, PATH_MAX);
        strncat(full_service_path, bpath, PATH_MAX);

        struct stat original_service_stat;
        if (stat(full_service_path, &original_service_stat) != 0) {
            return -errno;
        }


        struct service_desc service_desc = { .start_len = 0, .stop_len = 0, .conf_len = 0 };

        switch (service_type) {
        case SERVICE_TYPE_RUNIT: {
            service_desc.start_len =
                snprintf(service_desc.start, PATH_MAX, "/bedrock/bin/strat -r %s %s/run", service_stratum, full_service_path);

            // If there's a finish file, record to execute it after the service has stopped
            char after_stop_file_path[PATH_MAX];
            strncpy(after_stop_file_path, full_service_path, PATH_MAX);
            strcat(after_stop_file_path, "/finish");
            if (access(after_stop_file_path, F_OK) == 0) {
                service_desc.after_stop_len = snprintf(
                    service_desc.after_stop, PATH_MAX, "/bedrock/bin/strat -r %s %s",
                    service_stratum, after_stop_file_path
                );
            }

            char conf_file_path[PATH_MAX];
            strncpy(conf_file_path, full_service_path, PATH_MAX);
            strcat(conf_file_path, "/conf");
            if (access(conf_file_path, F_OK) == 0) {
                service_desc.conf_len = strlen(conf_file_path);
                strncpy(service_desc.conf, conf_file_path, service_desc.conf_len);
            }

            char check_file_path[PATH_MAX];
            strncpy(check_file_path, full_service_path, PATH_MAX);
            strcat(check_file_path, "/check");
            if (access(check_file_path, F_OK) == 0) {
                service_desc.check_len = snprintf(
                    service_desc.check, PATH_MAX, "/bedrock/bin/strat -r %s %s",
                    service_stratum, check_file_path
                );
            }

            break;
        }
        case SERVICE_TYPE_OPENRC: {
            char command_base[PATH_MAX];
            snprintf(command_base,
                     PATH_MAX,
                     "/bedrock/bin/strat -r %s " STRATA_ROOT "%s/sbin/openrc-run %s",
                     service_stratum, service_stratum, full_service_path
            );

            service_desc.start_len =
                snprintf(service_desc.start, PATH_MAX, "%s start", command_base);
            service_desc.stop_len =
                snprintf(service_desc.stop, PATH_MAX, "%s stop", command_base);

            char *service_name = basename(bpath);

            char conf_file_path[PATH_MAX];
            size_t conf_file_len =
                snprintf(conf_file_path, PATH_MAX, STRATA_ROOT "%s/etc/conf.d/%s", service_stratum, service_name);
            if (access(conf_file_path, F_OK) == 0) {
                service_desc.conf_len = conf_file_len;
                strncpy(service_desc.conf, conf_file_path, conf_file_len);
            }

            // This only work with daemons started via start-stop-daemon and without custom PID files.
            // Generally, OpenRC write a file from which PIDFile can be determined after service start,
            // but only after service start.. Otherwise, the pattern seems to be /run/supervise-name.pid
            service_desc.pidfile_len = snprintf(service_desc.pidfile, PATH_MAX, "/run/supervise-%s.pid", service_name);

            // openrc-run refuses to run if this file doesn't exist
            char softlevel_path[PATH_MAX];
            snprintf(softlevel_path, PATH_MAX, STRATA_ROOT "%s/run/openrc/softlevel", service_stratum);
            if (!access(softlevel_path, F_OK))
                fclose(fopen(softlevel_path, "w"));
        }
        }

        // Allocate space for a generated service + service path data
        *generated_service = malloc(sizeof(struct generated_service) + strlen(full_service_path) + 1);
        if (*generated_service == NULL)
            return -ENOMEM;

        strcpy((*generated_service)->original_path, full_service_path);

        switch (init_stratum_service_type) {
        case SERVICE_TYPE_SYSTEMD:
            ;
            int rv = generate_systemd_service(&service_desc, *generated_service);
            if (rv < 0)
                return rv;

            break;
        }
}

static inline int read_service(struct cfg_entry *cfg, const char *const ipath, size_t ipath_len,
                               char *buf, size_t size, off_t offset, struct back_entry *back, char *bpath,
                               enum service_type service_type) {
    if (init_stratum_service_type == service_type) {
        switch (service_type) {
        case SERVICE_TYPE_SYSTEMD:
            return inject_ini(cfg, ipath, ipath_len, buf, size, offset);
            break;
        }
    } else {
        struct generated_service *generated_service = NULL;
        generate_service_for(back, bpath, service_type, &generated_service);

        strncpy(buf, generated_service->service_text, generated_service->service_text_len);

        return generated_service->service_text_len;
    }
}
